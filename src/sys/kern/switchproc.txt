/* This is just a work-in-progress. DO NOT USE AS-IS. */

struct proc *nextready()
{
	struct proc *pp = CURRENT;
	struct proc *p = pp;
	
	/* return next ready proc or idle while no proc is ready */
	while (1) {
		if (++p >= proc[NPROC])
			p = &proc[0];
		if (p == pp)
			cpuidle();
		if (p->p_status == P_READY)
			return p;
		if (p->p_status == P_RUNNING)
			panic("nextready: extra running");
	}
}

nextproc()
{
	chksigs();	/* check if any signals are pending */
	
	switchthread(CURRENT->p_sp, nextready()->p_sp);
	CURRENT->p_state = P_RUNNING;
	G_cputime = CURRENT->p_cputimeinterval;
}

/* give up CPU for another ready process */
yield()
{
	++CURRENT->p_insys;
	CURRENT->p_state = P_READY;
	nextproc();
	--CURRENT->p_insys;
}

psleep(event) /* sleeps until event */
{
	++CURRENT->p_insys;
	CURRENT->p_waitfor = event; /* something like this? */
	CURRENT->p_state = P_SLEEPING;
	nextproc();
	--CURRENT->p_insys;
}

/* clock tick interrupt handler, almost directly from UZIX */
/* might be split up for different interrupts (1, 3, 5) */
clocktick()
{
	/* increment system time */
	incrtick(&G_ticks);
	
	/* increment proc time (p_utime or p_stime) if it's P_RUNNING */
	if (CURRENT->p_state == P_RUNNING)
		incrtick(CURRENT->p_insys
				? &CURRENT->p_stime
				: &CURRENT->p_utime);
	
	/* do once-per second things */
	if (++sec == TICKSPERSEC) {
		sec = 0;
		updttod();	/* update time-of-day */
		
		/* update process alarm clocks */
		/*
		 * This updates ITIMER_REAL, but we really should update three
		 * timers here:
		 * ITIMER_REAL: update for every clock tick
		 * ITIMER_VIRTUAL: update if proc is P_RUNNING and not insys
		 * ITIMER_PROF: update if proc is P_RUNNING
		 */
		/* perhaps use a delta list for this? */
		for (p = &G_proc[0]; p < &G_proc[NPROC]; ++p)
			if (p->p_alarm) {
				if (--p->p_alarm == 0)
					sendsig(p, SIGALRM);
			}
	}
	
	if (--G_cputime <= 0 && !CURRENT->p_insys)
		yield();
}
